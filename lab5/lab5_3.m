%Использование сети Хэмминга для распознавания статических образов
%[4,3,2]
n0 =      [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 -1 -1 -1 -1 -1 -1 -1];
       
n1 =      [-1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1];
       
n2 =      [+1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1];
       
n3 =      [-1 -1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 +1 +1 +1 +1 -1 -1;
           -1 -1 -1 -1 +1 +1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 +1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 -1 -1];
       
n4 =      [-1 +1 +1 -1 -1 -1 -1 +1 +1 -1;
           -1 +1 +1 -1 -1 -1 -1 +1 +1 -1;
           -1 +1 +1 -1 -1 -1 -1 +1 +1 -1;
           -1 +1 +1 -1 -1 -1 -1 +1 +1 -1;
           -1 +1 +1 -1 -1 -1 -1 +1 +1 -1;
           -1 +1 +1 +1 +1 +1 +1 +1 +1 -1;
           -1 +1 +1 +1 +1 +1 +1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1;
           -1 -1 -1 -1 -1 -1 -1 +1 +1 -1];

n6 =      [+1 +1 +1 +1 +1 +1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 -1 -1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 -1 -1 -1 -1;
           +1 +1 -1 -1 +1 +1 -1 -1 -1 -1;
           +1 +1 -1 -1 +1 +1 -1 -1 -1 -1;
           +1 +1 -1 -1 +1 +1 -1 -1 -1 -1;
           +1 +1 -1 -1 +1 +1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 -1 -1 -1 -1];
       
n9 =      [-1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 -1 -1 -1 -1 +1 +1;
           -1 -1 -1 -1 -1 -1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1];
      

Q = 7;
Patterns = [n0(:), n1(:), n2(:), n3(:), n4(:), n6(:), n9(:)];
eps = 1 / (Q - 1);

Result = 10 * 12;

IW = [n0(:)'; n1(:)'; n2(:)'; n3(:)'; n4(:)'; n6(:)'; n9(:)'];
b = Result * ones(Q, 1);

a = zeros(Q, Q);
for i = 1 : Q
    a(:, i) = IW * Patterns(:, i) + b;
end

network = newhop(a);
network.biasConnect(1) = 0;
network.layers{1}.transferFcn = 'poslin';
network.LW{1, 1} = eye(Q, Q) * (1 + eps) - ones(Q, Q) * eps;
view(network);

n_iterations = 600;
current = n3(:);
A = IW * current + b;
Result = sim(network, {1 n_iterations}, {}, A);
A = Result{n_iterations};
A = IW(find(A == max(A)), :)';

figure('Name', 'Цифра 3')
Result = reshape(A, 12, 10);
Result(Result >= 0) = 2;
Result(Result < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
image(Result);
colormap(map)
axis off
axis image


n_iterations = 600;
Noise = rand(12 * 10);
M = 0.2;
current = n1(:);

for i = 1 : 12 * 10
    if Noise(i) < M
        current(i) = -current(i);
    end
end

 
Result = reshape(current, 12, 10);
Result(Result >=0) = 2;
Result(Result < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
figure('Name', 'Цифра 1, зашумленная на 20%');
image(Result); colormap(map)
axis off
axis image
 
A = IW * current + b;
Result = sim(network, {1 n_iterations}, {}, A);
A = Result{n_iterations};
index = find(A == max(A));
A = IW(index, :)';
 
Result = reshape(A, 12, 10);
Result(Result >=0) = 2;
Result(Result < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
figure('Name', 'Цифра 1')
image(Result); colormap(map)
axis off
axis image

n_iterations = 600;
Noise = rand(12 * 10);
M = 0.3;
current = n0(:);

for i = 1 : 12 * 10
    if Noise(i) < M
        current(i) = -current(i);
    end
end

 
Result = reshape(current, 12, 10);
Result(Result >=0) = 2;
Result(Result < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
figure('Name', 'Цифра 0, зашумленная на 30%');
image(Result); colormap(map)
axis off
axis image
 
A = IW * current + b;
Result = sim(network, {1 n_iterations}, {}, A);
A = Result{n_iterations};
A = IW(find(A == max(A)), :)';
 
Result = reshape(A, 12, 10);
Result(Result >=0) = 2;
Result(Result < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
figure('Name', 'Цифра 0')
image(Result); colormap(map)
axis off
axis image